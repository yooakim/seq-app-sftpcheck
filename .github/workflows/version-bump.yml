# Version Bump Workflow for Seq.App.SftpCheck
#
# This workflow automates the version bump process following SemVer:
#   1. Updates the version in Directory.Build.props
#   2. Commits the change
#   3. Creates and pushes a version tag
#   4. The tag push triggers the release.yml workflow
#
# Usage:
#   1. Go to Actions > Version Bump
#   2. Select the bump type (major, minor, patch) or specify a custom version
#   3. Optionally add a prerelease suffix (e.g., alpha, beta, rc.1)
#   4. Run the workflow
#
# Examples:
#   - Current: 1.0.0, Bump: minor -> 1.1.0
#   - Current: 1.0.0, Bump: major -> 2.0.0
#   - Current: 1.0.0, Bump: patch, Prerelease: rc.1 -> 1.0.1-rc.1
#   - Custom version: 2.0.0-beta.1 -> 2.0.0-beta.1

name: Version Bump

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Version bump type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
        default: patch
      custom_version:
        description: "Custom version (only used if bump_type is 'custom', e.g., 2.0.0)"
        required: false
        type: string
      prerelease:
        description: "Prerelease suffix (e.g., alpha, beta, rc.1) - leave empty for stable release"
        required: false
        type: string
      dry_run:
        description: "Dry run (don't push changes)"
        required: false
        type: boolean
        default: false

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use PAT to bypass branch protection rules
          # Create a fine-grained PAT with 'contents: write' permission
          # and save it as a repository secret named 'PAT'
          token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Calculate new version
        id: version
        run: |
          # Read current version from Directory.Build.props
          CURRENT_VERSION=$(grep -oP '(?<=<VersionPrefix>)[^<]+' Directory.Build.props)
          # Check for existing VersionSuffix
          CURRENT_SUFFIX=$(grep -oP '(?<=<VersionSuffix>)[^<]*' Directory.Build.props || echo "")

          if [ -n "$CURRENT_SUFFIX" ]; then
            echo "Current version: $CURRENT_VERSION-$CURRENT_SUFFIX"
            FULL_CURRENT="$CURRENT_VERSION-$CURRENT_SUFFIX"
          else
            echo "Current version: $CURRENT_VERSION"
            FULL_CURRENT="$CURRENT_VERSION"
          fi

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Calculate new version based on bump type
          case "${{ inputs.bump_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            custom)
              if [ -z "${{ inputs.custom_version }}" ]; then
                echo "::error::Custom version is required when bump_type is 'custom'"
                exit 1
              fi
              # Extract base version from custom (remove any prerelease suffix for props)
              CUSTOM="${{ inputs.custom_version }}"
              BASE_CUSTOM=$(echo "$CUSTOM" | cut -d'-' -f1)
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_CUSTOM"
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"

          # Determine prerelease suffix
          PRERELEASE=""
          if [ -n "${{ inputs.prerelease }}" ]; then
            PRERELEASE="${{ inputs.prerelease }}"
            TAG_VERSION="${NEW_VERSION}-${PRERELEASE}"
          elif [ "${{ inputs.bump_type }}" == "custom" ] && [[ "${{ inputs.custom_version }}" == *"-"* ]]; then
            # Preserve prerelease from custom version
            PRERELEASE=$(echo "${{ inputs.custom_version }}" | cut -d'-' -f2-)
            TAG_VERSION="${{ inputs.custom_version }}"
          else
            TAG_VERSION="${NEW_VERSION}"
          fi

          # Check if anything actually changes
          if [ "$NEW_VERSION" == "$CURRENT_VERSION" ] && [ "$PRERELEASE" == "$CURRENT_SUFFIX" ]; then
            echo "::error::New version ($TAG_VERSION) is the same as current version ($FULL_CURRENT). Nothing to bump."
            exit 1
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$TAG_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT

          echo "New version prefix: $NEW_VERSION"
          echo "Prerelease suffix: ${PRERELEASE:-none}"
          echo "Tag version: v$TAG_VERSION"

      - name: Check if tag already exists
        run: |
          TAG_NAME="v${{ steps.version.outputs.tag_version }}"
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "::error::Tag $TAG_NAME already exists!"
            exit 1
          fi
          echo "Tag $TAG_NAME is available"

      - name: Update Directory.Build.props
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          PRERELEASE="${{ steps.version.outputs.prerelease }}"

          # Update the VersionPrefix in Directory.Build.props
          sed -i "s|<VersionPrefix>.*</VersionPrefix>|<VersionPrefix>${NEW_VERSION}</VersionPrefix>|" Directory.Build.props

          # Handle VersionSuffix
          if [ -n "$PRERELEASE" ]; then
            # Check if VersionSuffix element exists
            if grep -q "<VersionSuffix>" Directory.Build.props; then
              # Update existing VersionSuffix
              sed -i "s|<VersionSuffix>.*</VersionSuffix>|<VersionSuffix>${PRERELEASE}</VersionSuffix>|" Directory.Build.props
            else
              # Add VersionSuffix after VersionPrefix
              sed -i "s|</VersionPrefix>|</VersionPrefix>\n        <VersionSuffix>${PRERELEASE}</VersionSuffix>|" Directory.Build.props
            fi
          else
            # Remove VersionSuffix if it exists (stable release)
            sed -i "/<VersionSuffix>.*<\/VersionSuffix>/d" Directory.Build.props
          fi

          echo "Updated Directory.Build.props:"
          cat Directory.Build.props

      - name: Verify build
        run: |
          dotnet restore
          dotnet build -c Release --no-restore

      - name: Commit and tag
        if: ${{ inputs.dry_run == false }}
        run: |
          TAG_VERSION="${{ steps.version.outputs.tag_version }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          git add Directory.Build.props
          git commit -m "chore: bump version to ${TAG_VERSION}" || {
            echo "::error::Failed to commit. This may be due to branch protection rules."
            echo "::error::Please create a Personal Access Token (PAT) with 'contents: write' permission"
            echo "::error::and add it as a repository secret named 'PAT'."
            exit 1
          }
          git tag -a "v${TAG_VERSION}" -m "Release v${TAG_VERSION}"

          echo "Created commit and tag v${TAG_VERSION}"

      - name: Push changes
        if: ${{ inputs.dry_run == false }}
        run: |
          git push origin ${{ github.ref_name }} || {
            echo "::error::Failed to push to branch. This is likely due to branch protection rules."
            echo "::error::Please ensure a PAT secret is configured with 'contents: write' permission,"
            echo "::error::or add a branch protection bypass rule for github-actions[bot]."
            exit 1
          }
          git push origin "v${{ steps.version.outputs.tag_version }}"

      - name: Summary
        run: |
          TAG_VERSION="${{ steps.version.outputs.tag_version }}"
          CURRENT="${{ steps.version.outputs.current_version }}"
          NEW="${{ steps.version.outputs.new_version }}"

          echo "## Version Bump Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Previous Version | \`${CURRENT}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| New Version | \`${NEW}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | \`v${TAG_VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Bump Type | \`${{ inputs.bump_type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Prerelease | \`${{ inputs.prerelease || 'none' }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Dry Run | \`${{ inputs.dry_run }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.dry_run }}" == "true" ]; then
            echo "⚠️ **This was a dry run. No changes were pushed.**" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **Version bump complete!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The tag push will trigger the [Release workflow](../actions/workflows/release.yml) automatically." >> $GITHUB_STEP_SUMMARY
          fi
